import { basename, resolve } from 'path';
import { writeFileSync, readFileSync, existsSync } from 'fs';
import colors from 'ansi-colors';
import { ITiddlerFields } from 'tw5-typed';
import { minify as htmlMinify } from 'html-minifier-terser';
import { rebuild } from './packup';
import { tiddlywiki, mkdirsForFileSync } from './utils';

const sleep = (millionseconds: number) =>
  new Promise<void>(resolve => setTimeout(() => resolve(), millionseconds));

const printPlugins = (plugins: Map<string, string>) => {
  // eslint-disable-next-line no-console
  console.log(colors.bgCyan.black.bold(' Minimized plugins '));
  plugins.forEach((plugin, title) => {
    let size = plugin.length;
    let unit = 'B  ';
    if (size > 1024) {
      size /= 1024;
      unit = 'KiB';
    }
    if (size > 1024) {
      size /= 1024;
      unit = 'MiB';
    }
    const sizeFormatted = `${size.toFixed(2)} ${unit}`.padStart(11);
    // eslint-disable-next-line no-console
    console.log(colors.cyan(`${sizeFormatted}   ${title}`));
  });
  // eslint-disable-next-line no-console
  console.log('');
};

const waitForFile = (path: string) =>
  new Promise<void>(resolve => {
    const id = setInterval(() => {
      resolve();
      if (existsSync(path)) {
        resolve();
        clearInterval(id);
      }
    }, 100);
  });

export const build = async (output: string) => {
  const $tw = tiddlywiki();
  const plugins = await rebuild($tw, 'src', undefined, false);
  const pluginJsons = new Map<string, string>();
  plugins.forEach(plugin => {
    const pluginTiddlerName = `${basename(
      ($tw.utils as any).generateTiddlerFilepath(plugin.title, {}),
    )}.json`;
    const path = resolve(output, pluginTiddlerName);
    mkdirsForFileSync(path);
    const jsonStr = JSON.stringify(plugin);
    pluginJsons.set(plugin.title, jsonStr);
    writeFileSync(path, jsonStr);
  });
  printPlugins(pluginJsons);
  return plugins;
};

export const buildLibrary = async (output: string) => {
  const $tw = tiddlywiki();
  const plugins: Record<string, ITiddlerFields> = {};
  const pluginJsons = new Map<string, string>();
  (await rebuild($tw, 'src', undefined, false)).forEach(plugin => {
    const jsonStr = JSON.stringify(plugin);
    pluginJsons.set(plugin.title, jsonStr);
    plugins[plugin.title] = plugin;
  });
  printPlugins(pluginJsons);
  const pluginPath = ($tw as any).getLibraryItemSearchPaths(
    $tw.config.pluginsPath,
  );
  // eslint-disable-next-line no-console
  console.log(colors.green.bold('Generating plugin library...'));
  tiddlywiki(
    [
      /* 收集所有已安装插件 */
      {
        title: '$:/UpgradeLibrary',
        type: 'application/json',
        'plugin-type': 'library',
        text: JSON.stringify({ tiddlers: plugins }),
      },
      ...[
        'tiddlywiki/filesystem',
        'tiddlywiki/tiddlyweb',
        'tiddlywiki/pluginlibrary',
      ].map(pluginName =>
        ($tw as any).loadPluginFolder(
          ($tw as any).findLibraryItem(pluginName, pluginPath),
        ),
      ),
    ],
    'wiki',
    [
      ...['--output', resolve(output)] /* 指定输出路径 */,
      ...[
        '--savelibrarytiddlers',
        '$:/UpgradeLibrary',
        '',
        'recipes/library/tiddlers/',
        '$:/UpgradeLibrary/List',
      ] /* 导出指定的插件 */,
      ...[
        '--savetiddler',
        '$:/UpgradeLibrary/List',
        'recipes/library/tiddlers.json',
      ] /* 生成插件集合JSON文件 */,
      ...[
        '--rendertiddler',
        '$:/plugins/tiddlywiki/pluginlibrary/library.template.html',
        'index.html',
        'text/plain',
      ] /* 生成插件库HTML文件 */,
      ...[
        '--deletetiddlers',
        '[[$:/UpgradeLibrary]] [[$:/UpgradeLibrary/List]]',
      ] /* 删掉中间内容 */,
    ],
  );

  // 最小化：HTML
  const HTMLPath = resolve(output, 'index.html');
  // index.html 的生成是异步而无法控制，很烦
  await waitForFile(HTMLPath);
  const result = await htmlMinify(readFileSync(HTMLPath, 'utf-8'), {
    caseSensitive: true,
    collapseBooleanAttributes: false,
    collapseInlineTagWhitespace: false,
    collapseWhitespace: true,
    conservativeCollapse: true,
    continueOnParseError: true,
    customAttrCollapse: /.*/,
    decodeEntities: true,
    html5: true,
    ignoreCustomFragments: [/<#[\s\S]*?#>/, /<%[\s\S]*?%>/, /<\?[\s\S]*?\?>/],
    includeAutoGeneratedTags: false,
    keepClosingSlash: false,
    maxLineLength: 0,
    minifyCSS: true,
    minifyJS: true,
    minifyURLs: true,
    preserveLineBreaks: false,
    preventAttributesEscaping: false,
    processConditionalComments: true,
    processScripts: ['text/html'],
    removeAttributeQuotes: true,
    removeComments: true,
    removeEmptyAttributes: true,
    removeEmptyElements: false,
    removeOptionalTags: true,
    removeRedundantAttributes: true,
    removeScriptTypeAttributes: true,
    removeStyleLinkTypeAttributes: true,
    removeTagWhitespace: true,
    sortAttributes: true,
    sortClassName: true,
    trimCustomFragments: true,
    useShortDoctype: true,
  });
  writeFileSync(HTMLPath, result);
  await sleep(1000);
};
